"""Compiles nodes from the parser into Python code."""

import typing as t
from contextlib import contextmanager
from functools import update_wrapper
from io import StringIO
from itertools import chain
from keyword import iskeyword as is_python_keyword

from markupsafe import escape
from markupsafe import Markup

from . import nodes
from .exceptions import TemplateAssertionError
from .idtracking import Symbols
from .idtracking import VAR_LOAD_ALIAS
from .idtracking import VAR_LOAD_PARAMETER
from .idtracking import VAR_LOAD_RESOLVE
from .idtracking import VAR_LOAD_UNDEFINED
from .nodes import EvalContext
from .optimizer import Optimizer
from .utils import _PassArg
from .utils import concat
from .visitor import NodeVisitor

if t.TYPE_CHECKING:
    import typing_extensions as te

    from .environment import Environment

F = t.TypeVar("F", bound=t.Callable[..., t.Any])

operators = {
    "eq": "==",
    "ne": "!=",
    "gt": ">",
    "gteq": ">=",
    "lt": "<",
    "lteq": "<=",
    "in": "in",
    "notin": "not in",
}


def optimizeconst(f: F) -> F:
    def new_func(
        self: "CodeGenerator", node: nodes.Expr, frame: "Frame", **kwargs: t.Any
    ) -> t.Any:
        # Only optimize if the frame is not volatile
        if self.optimizer is not None and not frame.eval_ctx.volatile:
            new_node = self.optimizer.visit(node, frame.eval_ctx)

            if new_node != node:
                return self.visit(new_node, frame)

        return f(self, node, frame, **kwargs)

    return update_wrapper(t.cast(F, new_func), f)


def _make_binop(op: str) -> t.Callable[["CodeGenerator", nodes.BinExpr, "Frame"], None]:
    @optimizeconst
    def visitor(self: "CodeGenerator", node: nodes.BinExpr, frame: Frame) -> None:
        if (
            self.environment.sandboxed and op in self.environment.intercepted_binops  # type: ignore
        ):
            self.write(f"environment.call_binop(context, {op!r}, ")
            self.visit(node.left, frame)
            self.write(", ")
            self.visit(node.right, frame)
        else:
            self.write("(")
            self.visit(node.left, frame)
            self.write(f" {op} ")
            self.visit(node.right, frame)

        self.write(")")

    return visitor


def _make_unop(
    op: str,
) -> t.Callable[["CodeGenerator", nodes.UnaryExpr, "Frame"], None]:
    @optimizeconst
    def visitor(self: "CodeGenerator", node: nodes.UnaryExpr, frame: Frame) -> None:
        if (
            self.environment.sandboxed and op in self.environment.intercepted_unops  # type: ignore
        ):
            self.write(f"environment.call_unop(context, {op!r}, ")
            self.visit(node.node, frame)
        else:
            self.write("(" + op)
            self.visit(node.node, frame)

        self.write(")")

    return visitor


def generate(
    node: nodes.Template,
    environment: "Environment",
    name: t.Optional[str],
    filename: t.Optional[str],
    stream: t.Optional[t.TextIO] = None,
    defer_init: bool = False,
    optimized: bool = True,
) -> t.Optional[str]:
    """Generate the python source for a node tree."""
    if not isinstance(node, nodes.Template):
        raise TypeError("Can't compile non template nodes")

    generator = environment.code_generator_class(
        environment, name, filename, stream, defer_init, optimized
    )
    generator.visit(node)

    if stream is None:
        return generator.stream.getvalue()  # type: ignore

    return None


def has_safe_repr(value: t.Any) -> bool:
    """Does the node have a safe representation?"""
    if value is None or value is NotImplemented or value is Ellipsis:
        return True

    if type(value) in {bool, int, float, complex, range, str, Markup}:
        return True

    if type(value) in {tuple, list, set, frozenset}:
        return all(has_safe_repr(v) for v in value)

    if type(value) is dict:  # noqa E721
        return all(has_safe_repr(k) and has_safe_repr(v) for k, v in value.items())

    return False


def find_undeclared(
    nodes: t.Iterable[nodes.Node], names: t.Iterable[str]
) -> t.Set[str]:
    """Check if the names passed are accessed undeclared.  The return value
    is a set of all the undeclared names from the sequence of names found.
    """
    visitor = UndeclaredNameVisitor(names)
    try:
        for node in nodes:
            visitor.visit(node)
    except VisitorExit:
        pass
    return visitor.undeclared


class MacroRef:
    def __init__(self, node: t.Union[nodes.Macro, nodes.CallBlock]) -> None:
        self.node = node
        self.accesses_caller = False
        self.accesses_kwargs = False
        self.accesses_varargs = False


class Frame:
    """Holds compile time information for us."""

    def __init__(
        self,
        eval_ctx: EvalContext,
        parent: t.Optional["Frame"] = None,
        level: t.Optional[int] = None,
    ) -> None:
        self.eval_ctx = eval_ctx

        # the parent of this frame
        self.parent = parent

        if parent is None:
            self.symbols = Symbols(level=level)

            # in some dynamic inheritance situations the compiler needs to add
            # write tests around output statements.
            self.require_output_check = False

            # inside some tags we are using a buffer rather than yield statements.
            # this for example affects {% filter %} or {% macro %}.  If a frame
            # is buffered this variable points to the name of the list used as
            # buffer.
            self.buffer: t.Optional[str] = None

            # the name of the block we're in, otherwise None.
            self.block: t.Optional[str] = None

        else:
            self.symbols = Symbols(parent.symbols, level=level)
            self.require_output_check = parent.require_output_check
            self.buffer = parent.buffer
            self.block = parent.block

        # a toplevel frame is the root + soft frames such as if conditions.
        self.toplevel = False

        # the root frame is basically just the outermost frame, so no if
        # conditions.  This information is used to optimize inheritance
        # situations.
        self.rootlevel = False

        # variables set inside of loops and blocks should not affect outer frames,
        # but they still needs to be kept track of as part of the active context.
        self.loop_frame = False
        self.block_frame = False

        # track whether the frame is being used in an if-statement or conditional
        # expression as it determines which errors should be raised during runtime
        # or compile time.
        self.soft_frame = False

    def copy(self) -> "Frame":
        """Create a copy of the current one."""
        rv = object.__new__(self.__class__)
        rv.__dict__.update(self.__dict__)
        rv.symbols = self.symbols.copy()
        return rv

    def inner(self, isolated: bool = False) -> "Frame":
        """Return an inner frame."""
        if isolated:
            return Frame(self.eval_ctx, level=self.symbols.level + 1)
        return Frame(self.eval_ctx, self)

    def soft(self) -> "Frame":
        """Return a soft frame.  A soft frame may not be modified as
        standalone thing as it shares the resources with the frame it
        was created of, but it's not a rootlevel frame any longer.

        This is only used to implement if-statements and conditional
        expressions.
        """
        rv = self.copy()
        rv.rootlevel = False
        rv.soft_frame = True
        return rv

    __copy__ = copy


class VisitorExit(RuntimeError):
    """Exception used by the `UndeclaredNameVisitor` to signal a stop."""


class DependencyFinderVisitor(NodeVisitor):
    """A visitor that collects filter and test calls."""

    def __init__(self) -> None:
        self.filters: t.Set[str] = set()
        self.tests: t.Set[str] = set()

    def visit_Filter(self, node: nodes.Filter) -> None:
        self.generic_visit(node)
        self.filters.add(node.name)

    def visit_Test(self, node: nodes.Test) -> None:
        self.generic_visit(node)
        self.tests.add(node.name)

    def visit_Block(self, node: nodes.Block) -> None:
        """Stop visiting at blocks."""


class UndeclaredNameVisitor(NodeVisitor):
    """A visitor that checks if a name is accessed without being
    declared.  This is different from the frame visitor as it will
    not stop at closure frames.
    """

    def __init__(self, names: t.Iterable[str]) -> None:
        self.names = set(names)
        self.undeclared: t.Set[str] = set()

    def visit_Name(self, node: nodes.Name) -> None:
        if node.ctx == "load" and node.name in self.names:
            self.undeclared.add(node.name)
            if self.undeclared == self.names:
                raise VisitorExit()
        else:
            self.names.discard(node.name)

    def visit_Block(self, node: nodes.Block) -> None:
        """Stop visiting a blocks."""


class CompilerExit(Exception):
    """Raised if the compiler encountered a situation where it just
    doesn't make sense to further process the code.  Any block that
    raises such an exception is not further processed.
    """


class CodeGenerator(NodeVisitor):
    def __init__(
        self,
        environment: "Environment",
        name: t.Optional[str],
        filename: t.Optional[str],
        stream: t.Optional[t.TextIO] = None,
        defer_init: bool = False,
        optimized: bool = True,
    ) -> None:
        if stream is None:
            stream = StringIO()
        self.environment = environment
        self.name = name
        self.filename = filename
        self.stream = stream
        self.created_block_context = False
        self.defer_init = defer_init
        self.optimizer: t.Optional[Optimizer] = None

        if optimized:
            self.optimizer = Optimizer(environment)

        # aliases for imports
        self.import_aliases: t.Dict[str, str] = {}

        # a registry for all blocks.  Because blocks are moved out
        # into the global python scope they are registered here
        self.blocks: t.Dict[str, nodes.Block] = {}

        # the number of extends statements so far
        self.extends_so_far = 0

        # some templates have a rootlevel extends.  In this case we
        # can safely assume that we're a child template and do some
        # more optimizations.
        self.has_known_extends = False

        # the current line number
        self.code_lineno = 1

        # registry of all filters and tests (global, not block local)
        self.tests: t.Dict[str, str] = {}
        self.filters: t.Dict[str, str] = {}

        # the debug information
        self.debug_info: t.List[t.Tuple[int, int]] = []
        self._write_debug_info: t.Optional[int] = None

        # the number of new lines before the next write()
        self._new_lines = 0

        # the line number of the last written statement
        self._last_line = 0

        # true if nothing was written so far.
        self._first_write = True

        # used by the `temporary_identifier` method to get new
        # unique, temporary identifier
        self._last_identifier = 0

        # the current indentation
        self._indentation = 0

        # Tracks toplevel assignments
        self._assign_stack: t.List[t.Set[str]] = []

        # Tracks parameter definition blocks
        self._param_def_block: t.List[t.Set[str]] = []

        # Tracks the current context.
        self._context_reference_stack = ["context"]

    @property
    def optimized(self) -> bool:
        return self.optimizer is not None

    # -- Various compilation helpers

    def fail(self, msg: str, lineno: int) -> "te.NoReturn":
        """Fail with a :exc:`TemplateAssertionError`."""
        raise TemplateAssertionError(msg, lineno, self.name, self.filename)

    def temporary_identifier(self) -> str:
        """Get a new unique identifier."""
        self._last_identifier += 1
        return f"t_{self._last_identifier}"

    def buffer(self, frame: Frame) -> None:
        """Enable buffering for the frame from that point onwards."""
        frame.buffer = self.temporary_identifier()
        self.writeline(f"{frame.buffer} = []")

    def return_buffer_contents(
        self, frame: Frame, force_unescaped: bool = False
    ) -> None:
        """Return the buffer contents of the frame."""
        if not force_unescaped:
            if frame.eval_ctx.volatile:
                self.writeline("if context.eval_ctx.autoescape:")
                self.indent()
                self.writeline(f"return Markup(concat({frame.buffer}))")
                self.outdent()
                self.writeline("else:")
                self.indent()
                self.writeline(f"return concat({frame.buffer})")
                self.outdent()
                return
            elif frame.eval_ctx.autoescape:
                self.writeline(f"return Markup(concat({frame.buffer}))")
                return
        self.writeline(f"return concat({frame.buffer})")

    def indent(self) -> None:
        """Indent by one."""
        self._indentation += 1

    def outdent(self, step: int = 1) -> None:
        """Outdent by step."""
        self._indentation -= step

    def start_write(self, frame: Frame, node: t.Optional[nodes.Node] = None) -> None:
        """Yield or write into the frame buffer."""
        if frame.buffer is None:
            self.writeline("yield ", node)
        else:
            self.writeline(f"{frame.buffer}.append(", node)

    def end_write(self, frame: Frame) -> None:
        """End the writing process started by `start_write`."""
        if frame.buffer is not None:
            self.write(")")

    def simple_write(
        self, s: str, frame: Frame, node: t.Optional[nodes.Node] = None
    ) -> None:
        """Simple shortcut for start_write + write + end_write."""
        self.start_write(frame, node)
        self.write(s)
        self.end_write(frame)

    def blockvisit(self, nodes: t.Iterable[nodes.Node], frame: Frame) -> None:
        """Visit a list of nodes as block in a frame.  If the current frame
        is no buffer a dummy ``if 0: yield None`` is written automatically.
        """
        try:
            self.writeline("pass")
            for node in nodes:
                self.visit(node, frame)
        except CompilerExit:
            pass

    def write(self, x: str) -> None:
        """Write a string into the output stream."""
        if self._new_lines:
            if not self._first_write:
                self.stream.write("\n" * self._new_lines)
                self.code_lineno += self._new_lines
                if self._write_debug_info is not None:
                    self.debug_info.append((self._write_debug_info, self.code_lineno))
                    self._write_debug_info = None
            self._first_write = False
            self.stream.write("    " * self._indentation)
            self._new_lines = 0
        self.stream.write(x)

    def writeline(
        self, x: str, node: t.Optional[nodes.Node] = None, extra: int = 0
    ) -> None:
        """Combination of newline and write."""
        self.newline(node, extra)
        self.write(x)

    def newline(self, node: t.Optional[nodes.Node] = None, extra: int = 0) -> None:
        """Add one or more newlines before the next write."""
        self._new_lines = max(self._new_lines, 1 + extra)
        if node is not None and node.lineno != self._last_line:
            self._write_debug_info = node.lineno
            self._last_line = node.lineno

    def signature(
        self,
        node: t.Union[nodes.Call, nodes.Filter, nodes.Test],
        frame: Frame,
        extra_kwargs: t.Optional[t.Mapping[str, t.Any]] = None,
    ) -> None:
        """Writes a function call to the stream for the current node.
        A leading comma is added automatically.  The extra keyword
        arguments may not include python keywords otherwise a syntax
        error could occur.  The extra keyword arguments should be given
        as python dict.
        """
        # if any of the given keyword arguments is a python keyword
        # we have to make sure that no invalid call is created.
        kwarg_workaround = any(
            is_python_keyword(t.cast(str, k))
            for k in chain((x.key for x in node.kwargs), extra_kwargs or ())
        )

        for arg in node.args:
            self.write(", ")
            self.visit(arg, frame)

        if not kwarg_workaround:
            for kwarg in node.kwargs:
                self.write(", ")
                self.visit(kwarg, frame)
            if extra_kwargs is not None:
                for key, value in extra_kwargs.items():
                    self.write(f", {key}={value}")
        if node.dyn_args:
            self.write(", *")
            self.visit(node.dyn_args, frame)

        if kwarg_workaround:
            if node.dyn_kwargs is not None:
                self.write(", **dict({")
            else:
                self.write(", **{")
            for kwarg in node.kwargs:
                self.write(f"{kwarg.key!r}: ")
                self.visit(kwarg.value, frame)
                self.write(", ")
            if extra_kwargs is not None:
                for key, value in extra_kwargs.items():
                    self.write(f"{key!r}: {value}, ")
            if node.dyn_kwargs is not None:
                self.write("}, **")
                self.visit(node.dyn_kwargs, frame)
                self.write(")")
            else:
                self.write("}")

        elif node.dyn_kwargs is not None:
            self.write(", **")
            self.visit(node.dyn_kwargs, frame)

    def pull_dependencies(self, nodes: t.Iterable[nodes.Node]) -> None:
        """Find all filter and test names used in the template and
        assign them to variables in the compiled namespace. Checking
        that the names are registered with the environment is done when
        compiling the Filter and Test nodes. If the node is in an If or
        CondExpr node, the check is done at runtime instead.

        .. versionchanged:: 3.0
            Filters and tests in If and CondExpr nodes are checked at
            runtime instead of compile time.
        """
        visitor = DependencyFinderVisitor()

        for node in nodes:
            visitor.visit(node)

        for id_map, names, dependency in (
            (self.filters, visitor.filters, "filters"),
            (
                self.tests,
                visitor.tests,
                "tests",
            ),
        ):
            for name in sorted(names):
                if name not in id_map:
                    id_map[name] = self.temporary_identifier()

                # add check during runtime that dependencies used inside of executed
                # blocks are defined, as this step may be skipped during compile time
                self.writeline("try:")
                self.indent()
                self.writeline(f"{id_map[name]} = environment.{dependency}[{name!r}]")
                self.outdent()
                self.writeline("except KeyError:")
                self.indent()
                self.writeline("@internalcode")
                self.writeline(f"def {id_map[name]}(*unused):")
                self.indent()
                self.writeline(
                    f'raise TemplateRuntimeError("No {dependency[:-1]}'
                    f' named {name!r} found.")'
                )
                self.outdent()
                self.outdent()

    def enter_frame(self, frame: Frame) -> None:
        undefs = []
        for target, (action, param) in frame.symbols.loads.items():
            if action == VAR_LOAD_PARAMETER:
                pass
            elif action == VAR_LOAD_RESOLVE:
                self.writeline(f"{target} = {self.get_resolve_func()}({param!r})")
            elif action == VAR_LOAD_ALIAS:
                self.writeline(f"{target} = {param}")
            elif action == VAR_LOAD_UNDEFINED:
                undefs.append(target)
            else:
                raise NotImplementedError("unknown load instruction")
        if undefs:
            self.writeline(f"{' = '.join(undefs)} = missing")

    def leave_frame(self, frame: Frame, with_python_scope: bool = False) -> None:
        if not with_python_scope:
            undefs = []
            for target in frame.symbols.loads:
                undefs.append(target)
            if undefs:
                self.writeline(f"{' = '.join(undefs)} = missing")

    def choose_async(self, async_value: str = "async ", sync_value: str = "") -> str:
        return async_value if self.environment.is_async else sync_value

    def func(self, name: str) -> str:
        return f"{self.choose_async()}def {name}"

    def macro_body(
        self, node: t.Union[nodes.Macro, nodes.CallBlock], frame: Frame
    ) -> t.Tuple[Frame, MacroRef]:
        """Dump the function def of a macro or call block."""
        frame = frame.inner()
        frame.symbols.analyze_node(node)
        macro_ref = MacroRef(node)

        explicit_caller = None
        skip_special_params = set()
        args = []

        for idx, arg in enumerate(node.args):
            if arg.name == "caller":
                explicit_caller = idx
            if arg.name in ("kwargs", "varargs"):
                skip_special_params.add(arg.name)
            args.append(frame.symbols.ref(arg.name))

        undeclared = find_undeclared(node.body, ("caller", "kwargs", "varargs"))

        if "caller" in undeclared:
            # In older Jinja versions there was a bug that allowed caller
            # to retain the special behavior even if it was mentioned in
            # the argument list.  However thankfully this was only really
            # working if it was the last argument.  So we are explicitly
            # checking this now and error out if it is anywhere else in
            # the argument list.
            if explicit_caller is not None:
                try:
                    node.defaults[explicit_caller - len(node.args)]
                except IndexError:
                    self.fail(
                        "When defining macros or call blocks the "
                        'special "caller" argument must be omitted '
                        "or be given a default.",
                        node.lineno,
                    )
            else:
                args.append(frame.symbols.declare_parameter("caller"))
            macro_ref.accesses_caller = True
        if "kwargs" in undeclared and "kwargs" not in skip_special_params:
            args.append(frame.symbols.declare_parameter("kwargs"))
            macro_ref.accesses_kwargs = True
        if "varargs" in undeclared and "varargs" not in skip_special_params:
            args.append(frame.symbols.declare_parameter("varargs"))
            macro_ref.accesses_varargs = True

        # macros are delayed, they never require output checks
        frame.require_output_check = False
        frame.symbols.analyze_node(node)
        self.writeline(f"{self.func('macro')}({', '.join(args)}):", node)
        self.indent()

        self.buffer(frame)
        self.enter_frame(frame)

        self.push_parameter_definitions(frame)
        for idx, arg in enumerate(node.args):
            ref = frame.symbols.ref(arg.name)
            self.writeline(f"if {ref} is missing:")
            self.indent()
            try:
                default = node.defaults[idx - len(node.args)]
            except IndexError:
                self.writeline(
                    f'{ref} = undefined("parameter {arg.name!r} was not provided",'
                    f" name={arg.name!r})"
                )
            else:
                self.writeline(f"{ref} = ")
                self.visit(default, frame)
            self.mark_parameter_stored(ref)
            self.outdent()
        self.pop_parameter_definitions()

        self.blockvisit(node.body, frame)
        self.return_buffer_contents(frame, force_unescaped=True)
        self.leave_frame(frame, with_python_scope=True)
        self.outdent()

        return frame, macro_ref

    def macro_def(self, macro_ref: MacroRef, frame: Frame) -> None:
        """Dump the macro definition for the def created by macro_body."""
        arg_tuple = ", ".join(repr(x.name) for x in macro_ref.node.args)
        name = getattr(macro_ref.node, "name", None)
        if len(macro_ref.node.args) == 1:
            arg_tuple += ","
        self.write(
            f"Macro(environment, macro, {name!r}, ({arg_tuple}),"
            f" {macro_ref.accesses_kwargs!r}, {macro_ref.accesses_varargs!r},"
            f" {macro_ref.accesses_caller!r}, context.eval_ctx.autoescape)"
        )

    def position(self, node: nodes.Node) -> str:
        """Return a human readable position for the node."""
        rv = f"line {node.lineno}"
        if self.name is not None:
            rv = f"{rv} in {self.name!r}"
        return rv

    def dump_local_context(self, frame: Frame) -> str:
        items_kv = ", ".join(
            f"{name!r}: {target}"
            for name, target in frame.symbols.dump_stores().items()
        )
        return f"{{{items_kv}}}"

    def write_commons(self) -> None:
        """Writes a common preamble that is used by root and block functions.
        Primarily this sets up common local helpers and enforces a generator
        through a dead branch.
        """
        self.writeline("resolve = context.resolve_or_missing")
        self.writeline("undefined = environment.undefined")
        self.writeline("concat = environment.concat")
        # always use the standard Undefined class for the implicit else of
        # conditional expressions
        self.writeline("cond_expr_undefined = Undefined")
        self.writeline("if 0: yield None")

    def push_parameter_definitions(self, frame: Frame) -> None:
        """Pushes all parameter targets from the given frame into a local
        stack that permits tracking of yet to be assigned parameters.  In
        particular this enables the optimization from `visit_Name` to skip
        undefined expressions for parameters in macros as macros can reference
        otherwise unbound parameters.
        """
        self._param_def_block.append(frame.symbols.dump_param_targets())

    def pop_parameter_definitions(self) -> None:
        """Pops the current parameter definitions set."""
        self._param_def_block.pop()

    def mark_parameter_stored(self, target: str) -> None:
        """Marks a parameter in the current parameter definitions as stored.
        This will skip the enforced undefined checks.
        """
        if self._param_def_block:
            self._param_def_block[-1].discard(target)

    def push_context_reference(self, target: str) -> None:
        self._context_reference_stack.append(target)

    def pop_context_reference(self) -> None:
        self._context_reference_stack.pop()

    def get_context_ref(self) -> str:
        return self._context_reference_stack[-1]

    def get_resolve_func(self) -> str:
        target = self._context_reference_stack[-1]
        if target == "context":
            return "resolve"
        return f"{target}.resolve"

    def derive_context(self, frame: Frame) -> str:
        return f"{self.get_context_ref()}.derived({self.dump_local_context(frame)})"

    def parameter_is_undeclared(self, target: str) -> bool:
        """Checks if a given target is an undeclared parameter."""
        if not self._param_def_block:
            return False
        return target in self._param_def_block[-1]

    def push_assign_tracking(self) -> None:
        """Pushes a new layer for assignment tracking."""
        self._assign_stack.append(set())

    def pop_assign_tracking(self, frame: Frame) -> None:
        """Pops the topmost level for assignment tracking and updates the
        context variables if necessary.
        """
        vars = self._assign_stack.pop()
        if (
            not frame.block_frame
            and not frame.loop_frame
            and not frame.toplevel
            or not vars
        ):
            return
        public_names = [x for x in vars if x[:1] != "_"]
        if len(vars) == 1:
            name = next(iter(vars))
            ref = frame.symbols.ref(name)
            if frame.loop_frame:
                self.writeline(f"_loop_vars[{name!r}] = {ref}")
                return
            if frame.block_frame:
                self.writeline(f"_block_vars[{name!r}] = {ref}")
                return
            self.writeline(f"context.vars[{name!r}] 1k:å)2"•y±¾°#%´uY]:
à¢"A¢!#1Á 9fw£reedŠígiùfz<lWŠ$¡$$,$2  (¡0Šy	úW|f|ò8†ù¼jòC¦bSA}†dVrABô«pÑgq2ghÚ2((5©$
0¹* ¤8e\{ æDveUu¾ÖeoÒ%]by`}oº\â("`ôˆ `  °¡# ,ref‚tqçdK_àjeŒàéÌçA6e~±nõctãPuº[2¬Šä:ª¥Ö%dhğp`š$kseS.5¦  ¤!¥0(DA84  swE<EÖé4qy]|¡=$îoôdhuªrA>.ı`-û´3(J²¾
!á$òíp2jç  NëSml^%¼J!Eqkf e×se`°-”Å([æRs+
ëAp004  00$#  énIDšë¨0d­ k˜#¢ 0òµ & WWåæ¯wwù|u¨à%²¡*0p+³ ¾9X'0n` 3Zm,a- kratcòWi¹ÿdõ`$)jmOD,`º²$p 8!'õd(>‚,nqi>t8l {îdäİ)s-:4¿ÚmD6(x¤$dZb3"a(H¦Sa@×ws}ŠM‚m)â	Bh,€  02e-¢¡NÅtÀd“íj'­bhwèygJËÛe¢å}`Àêív$¶(	aíjnFïpéorådähg¦U¬qVqëjoI}}q;
zb( 8 ¸ #I""û0.a(quféij]Nûu(866‘š% V "-¤$ ¦±gîFd.zÅÒ"VjçxéâBot¹Z7olRyüâ}Ei3Rcşs'mGd`Zğ5ân-á_~aow3—))±n%
""(0%ô0&mi;åV¨ğ ¸	„"°d0¡(¤!†Åm=skw¤Sg¸Î¼àf2(clhh]1p2_Ê¹it"è3n$]dó89J""i2k21¥b!f81Yïµîjs_Hò$ŒãmäNc"e­ndaY}Lø0oóC7ç_tw.6 ` ğm2®{úeRM{x³=¯0)k
ı `€³§5m`<I&Lìyl`V|ãx.ª#
80 ))#åvT>iSipCÇÀÔ_ëÕt,  èT`$H`(ƒı,·q~ww*²(^oæuú¶^`x*´s ®ú±w£†@cDm¨kÏa›~zGõa]!­@NæeÃe )¡«-? joéú
di  „¡ âcYev(b3<ïï`«p0Nôjdb~O~m` fkáo}.#ß­o9df+¤° `#`a;GctX ŒÄå?{7k4$¨h(×yìt.e/–O|gÿë=Ë4P fmT  /aı6¹ò:~a9 äzÁnúªí&r]®<]û%évwkÚVª_ry¦Ã_dqtns§eTŠ¡¢$¾bj0és}o^ÈítlsE`gp|¬&pôm{„e`J .'4€!jº´qOî~¦àlÉÒlËLnvtğ`ãMÁ|lo6J±!b8@(" &"Eøàïb|mh^¹åÙó,§099R×|å¬„8)
7xÔy%?âáàc.§VlvdO­Tá @°¤£j"ae3ä|*|°dv€j$¥¤ä¤ lk7bşelk¨ab5X£aÓ2TaÔ-á8`o`7€Ö§J®%²@" @‚5å"$iv0ûtX-è|%OqÉpGe¬{`l+A?¼˜\Fô8ç«nLsïº= ¦4+a"4†,^ï9L ¿ öæ@|uünaùú!	
,rx
p@H#,an`5v6.#äô  ¤  OoròQd /ë”yæDyRƒ|İm£gÅhãÑªb/²£}~e€Tô¥d;ë"!(³gheŞn©^Î1é?p›I#`î0á¨~gca+`fk' $x%cá-) }ithâTA=5<¨+Ş'1f¤ .oggà_ÑyraÎ#¥ç2 5'v-ÔíácfVtyfïW`").mfbˆ0Ù4)ºˆo|*g-$kùÅE2!npcxtwOw‚x$l0ñ¸ !¨&ÈEGö0ÏIU<)pi £Qn°q@wõ#tkde.`A¨(
0*/ot"¨LgåVhÁxâïQ`@iío6!Qqó+ps1]Gb1N86¨ëndòêäfÃn¡CK maĞ" ‚d äpPİé­|üe-åô -æ'Owç0zo,4±¾Gş^i~tcÅ`y?(LCÌ.aª3f `e%(cÉnppNiÁbìmp£sˆd)(C¨<¸Î~ö"rtlg_í)ä#kg
l/²ifÄ×é}j)FnqmÊ¤Äm¯bk‰ j2â¨@ ˆ»1" ¨D!óhmsyny)E`XL6ÿ7âfË`,~r«Lº !)‰ã0( ¤4À¼à°6Á,7/^Á#}tM|æ[cyhìá;,fQ`'[láfdkxnmf 4skg (¡BåïÃf*diíaªO*
à¦$0è!Œ !€S;î!á/6Is_$Ìï+#4¯Àåe•F:èLñidAi çãñ! âin`"o|(b	jtWæF]¡ëfD J!`o{´ ÀGlˆh <à 83æ[aí0i²œÈ`a0.mèå>"#n%c|è tktwö(#:?yÔp^àîm>h 0$#"º .1:(§!hmög|wşKu8íàtneIe¶ì®Q0«n49Ldîäá|Yfá$ipu3*"$(*3!!(b  È	#¡(i-Q = x,±o¶vŞ~émR‘vûqéí›'ãÍ* H¥ipf`1 ,@ApqlçiG2k&æ} \ne3ñcUhYú–ı bh%e3BY¸3©m..}l[r+b#rĞi]e{fñnYw;
 0È@/äf ceZ  ¥`ù&'l²âembc©s:!1$ hqz5Š`°€¢t!¦0õh(#Äde-&ËÂèI9)Õìv	ÒDP¤kg*9&± 9É

ĞC$4Š$ÈÌ d  ¤ygetV"~×á|è1ì@¨äê``~[&8Ãddeoy éJÉås2 ë`ç} Fã"sanÉQIw¶¢Ÿ 'ˆD y %„8:`   0Dgì{dÊ ò`4`@Œ ğC–+pt
"Rdp&^3yO5ğmÊå¸5im2(0´*ÿı©p|¡qo=cnšT[ ´K£¡.,ö0 aA† $tkg0,çzd&+çqğ4 ! wÜX!µc{(eLéëÄan«Nnı#]sãï
~E­â%ò^2ÊŠ 8º 3!2$SÄiÊç25 |xF`ş)-q˜Èg+e`$¨7ïO¢ğO>şXwfpBÄ `2wuH«{2­u==yÄtJ1¢!˜* ˆ,0˜Wnkz`äæ 2+ßt%±N~Xi(ê~nşaØl8ïpj}gjÏ?\	7;a.ã=òfVÃpdÙz: $M%jgòY­"È1¡¨¤ €).Àë1%$@«´6G8*†Y$'ÿ(99c03 €"ceê¥8W
Vt!ÿ9okffnQ Mê6"05* 8àk× Å’wD5I` :]ïpP D  ,b5X1å£. g|é[où`g`\\"Ejy ì3°R-" m`K1ej¢ 9Ç:kx,a{pnd/ClìrÌfèn+ôÎ%k/%t `jelÒ`­8y.
$ &( àè"ª€0 njáoöci>àYsTnts&Bâç=F2f©ºe2-ìôf_h rådFm 8 ".²¢  ;óld˜j6²YPÄ|lşp²ªv¦&ı"±3P¦ÉyìcåFgge²åÏ%)`mîjùD¥ ~!bc0$‰.Òñm!v±z@¬÷-!o`¹X'êmDM%lUi9± (%*„¥f3áMc®a/vf ]á8 ½FF‚­d7v_jtüõuÌ…˜=0Drx5šÀ`h4‚h2oQaua6mp}JUcVdN`ÆŞKàLs*4ø#lE×u:dÅlPc¶ô,¢$jk¶¸[elv,êGb]k}/YFCXõg‡ğó$ ’ä•¨° íwhl)uä_f lkndp
c( %f&  hwE[r.qÈtmYNs)0şcrAzz—3alaQte‘ JdJáo8
#+ Œ¡  0rˆ,ævm^5ôû[r6èÏdl¦ÿxÍaA.É@>€q$${g,ïîô$|1ÔspcrE]&&Ymñ!fOMfo É+9
aƒsqseUmO‚,c3{ÑÙoët ~oàg†än,q*j*Gm!B$ dÂ,óıLd¶=qu3G—–bc§_-„9áaz Wi´hå)T|)n}s¦²ù½ÀtA¡˜ ¨%@ò DGE·x´¥=@×0I[:l¡ª4£nÜ@a	`sUXK"·ŠAt üv%"PKS%eğ0òö~Dæy”wA-<Ç$\÷( zˆc  K,&m!|ô×‡ÓäDk¨;9Ş™  t0.& 8²«m§CQ3qgöèã÷XmFïY.Dçn¤óJ ’¢ !@6ğ ,¨
%!{n
epàÉê¹yÊb u£° ( , (à sal$&uRj4a})$ôl4meb1Ë neMpof"´cu%4)C*iNñÈÎjşõ9+ŠˆÛ % (xb" 1(Ãwl%,qo…rzq(}¨u)9 `8°!$HbD|şv@1=®'&göIRoNm'.)1oNrùzs.¨(q  i((%8D  å {àlv®uğ©õ¼Ì;mi¤|#Qé¤`sNìvh,RïJ|]0¤]rlùWº2í,~ÿrñÎ,uø\båcs	cı~\5ì,BìC‚(H€fR(bĞü‘ UáZ‹ †(*"8is¤! 2í "5í„Ák3sèv1ä),t(B%qb! 3¡
à¢4p €0jjdÙshkr $g²0µt²¼`h~`ğbÓ/TLEgiajpíÜv'nPz¹n§í>ëqlûä&Ojõ÷é&qê®‰pr"  22°±  #¡!Âjôæ,° `)bb!b¢ ='G¤ö*oHíñıvh3†`:A " `ê3p¸0¡$ &SÕ}†!£ği¤"E)la%*xfOm¡ìr,,T‚rj`¢`0ƒ*0`9 8¢-2óí,dî/Ñ\$¥|T`ešr#¢f$0 (á$0 éaâbj}'räá~u(q£/ÈÏUL³o~fæc±!B;,{ev×¥zjôJb1	x0üpL0,!Pa£°p8åi32Xn`ävègNë'ìåqf$d8áğ&i/-K²1¤m|è/kt#íáÁ¼g¤§ç.4øyı)ò%:`/]!@N®+ &d£  dr$}ágã7*ƒLc"<8î¡g¥ ®~$ê{+{èhpe}v%yº"( ,¦ 8"84f0sqHæ6OÔ9ôålbJi¬ˆ È24¢0`a*b1à )2fú{qADT8ñOs1'ãhoë §àFÃoi¡7¸k+âÅhP Åkcq/.n$-w«­n?_¡úsån}ö8x"|šrì y­à2(èh4Æ`$RLìa{J:Dâ((0!@$ (0 á,²p3H@d¡d2`0Š¡%"¹‹ ( …%&! 6)0ĞI4b.{Iäy&|-M¢¡84""Åğ& !$²qNfwr=t%??/iík~Z¨q†& ¦+ t 0Œ#©À'v$íipëÆY¡fT"n ap\·l`4î#jp#À3Ø(ê3FNIQ)eˆãíf:xLfkgolDHåZ `$, a&¢   0¡×1nãm'r¡h"yDn¹nã$dì&W€`2z+íÈD¡`sQŠI²e`2ashe~9`:¦1 i&a‚`f¡+è3"iïpeóeoac¿uiap<5ò$wáv{Qq`/ïuñvOu2"nòígoI"7>ï¤u  !a™p$ zb`CEia§U$ü´@rÁlëcödÅ}‡d:¢(¨†ä,Ø$ 4$!ó|Ïcq="bdmiv¯ÕmSMNGzzıjè0àsW-¤¨b	¨£¬  (uFö}‡h%Rhl`d)áĞœlîecJ«C-41plO3o8b'0¼zá(kñ(V"¦{Õ(Tzfmu>%(L¨  ,$éÜ¨A}%ºf9 c" õ…n-ë8qrUb¸+ €O¢ àº(äºàh! (ú¿ ¤qcFmcc—và!ïù>}ù,Yi,y"&âcD}ü'ıpã<	)åñ5ÀmFó…æaÃ)Mt# )P$0 !4(a 1` "5laow¢A<<Éo#.®+(÷u$Ø&7UH¥kt¤aeğR`ZÌPİêc5*gîte>D*‚ˆ(@"  ³   ² oò jk]per£ ]ïyCîe5ã€Câõd:^ B†3 âe-rgp1|¥au¢,b/dojñ?Rl¹ èwİü"kÔ{§qñG%'pwwuÕ2‹ÇÑE¥ph;sgeB²¡¿B9a,1¨4i9i#ú pb:fmg<c`MÔu$…ï# S+Kòrn[ y$ÑOïtt
@Œ2eÄ÷–3ï!M-£z%xhq/wk}_áaŒx`"¨~ ÅB  ¡ l1,h#nggx[Àâ`;dêãôıj?qj+hI9Êfífã*oOgf[)2ä"0³!{&t(@"ü´ã2ÙrzåÍÅ'Hìbx ·¡*híf¨1`à@W¨ğ¬ñMìî>÷riVUd9nfH¶ór¤†Rû^ añÿ°0[Ÿ¦q1  ƒÚdQà0!¸D±%r,aoôt¢A1€›m#bcşècÇÆbcyck
¬ q:(a ğ(¢~QhnnĞn\e%ÖäjÍøNGª}ój<ë)/kä;yK" !$¨ d"* 0ëí$7FvOÃå0);h~oêy/ÏÌ#`E9Œf,î£O]F{A9f3Ä,¸((  0FC¤¨s5èËî}+bt[fvgÆ%B.Grmüeğhíd¤0÷h0mé©°éÿN:Im0Ñ+^rdaj
)  ,!`2c¢$;g^p#üùfDEÎ4"`oN(+q1I\#şş/ãÍsCv´"1*P."rş7áNg
òj7lo^¢Š@Í£eæ‹xBb **!/e¤h&,Clmg.3@&À¯$te)ñen$`+zmTOı^~djü2rd/2néV¸5o;jöìvW±&_c¥s|ÿU'x M<7j%«7)†+)³`hb äOòEo~~nP$ıô"f'<J¯	Nh¢cZu«4ÿ4FJr 9¥&)í¢ÓUÌe&$ÇêuVß½ogk#i ª q¤åq..Zò½\5Dj®çºTÚDPOõMmï¦w|wb{$­bu3å[&kSt|9ÿ"ıŠ¨=rd$f 6ÿ4|VÈycë.eoÏ%,jofun<ë¯a`g¾dlfcov6u=u:úÒamM/ ,Ø(Vonu;M 0*`*%D¢ûá$,€Bb}Åáo&¡h v›cj3İVppi€„jŸòâèm!ö`M”oiø£~b"cx%{#"0 0ºlåv%"áL`hÈ#à¡ñ4}^!•p	ma¾E+0,udeLJ a$(ä#b!$"à©ˆy|°÷ñrkl?wˆw,ät²}IA e,1À#ødui4etì	>]<¡5`avä ió ïn‰ïdlX0|í¢2!m¤Be¢Q,a§Apq{$H%_­pqnu¸/~q! é1¤008ˆQig,kwød.l1rLğownüaîlåMêZÚ¬-)"0d%@òàè62 ¶‡øõrï* ! €Tğ@3"èû¤"cuf§~qaódn¥S[[/Jr°r 4bàHÊ X   aá Ğ`éd‰"!¡;uèTjgvíõeâé02ı´hw)-e4N°pl÷Ha}gMº Nkf—>*zH´$ "#X¨¡p$€¬¨|qñ<Dâx$Ç<T.¿"¢b (‘¢r  à4 0±G¥(!Šä0‹h&0"  4«$hv/g/wIZ{akrUô8 i`"¨a¤à&,"LnÔGqä8œ`c-@&deîr;~‡M/fp5ô4‚ëiaoI*(Ú6´ 3#äQÃ»ŠÈd€PáaÄ4 ä&"fgnô„í¼11íWe}d.duko.flxÑŸ2M`&=t1 ã A"ïCb¦|$d6"aITijD(ÍwA'42;1±…èd2ndFw.ITuøkp>nïyt#Nyş*û~üD¶¦j~/sb“r[í«¬*mxS»³q©T>_ ˜8¢eì=$­!j!ab¡²©#¤  h$b­Œ¢.ıNlåîw5¦% ("Ë"e,vakn2uek|åìéF§ø1` è8AB+!pG <á4Ò'|Aû¿)3VeFKt+tLPt¾;@ge]vpüS(#¸gá«}ôíH`
®Üuk€{­eõ.Ì$u%'ú -6£t-•ún€)¥©» 0090x &IF0(òê=fF4%¤`*` $x  %ë	¦d¦ƒ(0¶h`"5idFJw0pD%Nõ(¹“
   Bd(0ã6€´U´'7qöınDi#-éè¥'p8´_(‚~C¢Boæ`f¿qmM®¶7.FÜj¡ìBhl_Âe1’0¤0à€$ˆ0b¤"Rå}f77zŠ1aìnG¼   pH (€$a¬5 `¦" pOxôal¢&×¥g5ZEÄè}¨*8=!k7÷rædíªiõXIv|}úù jÚkl0ÑaQii5* J^lïJ* 5ö§ h ! p%(Ä`0 I¥|á!súÀ‚g¡ °$°4r£5è&*6htuo|Fé,J‹pJ '`°	 oøx`2!êxS$ìç9c¨nNwe"S)t„+±}Â%æ $°í/40«äªK( ì!4¦'"€$0b2xo#ésG/T¥`w**l>{J»w;fÚdS>~em#[ísÕ+S[nNezy)éì4<à/ $0  ¢Hñ 0 ¨f+Ee<"  ( ]h °)_ °(+-DP ` fCmG†|ô%jp¼!š¦ˆd  ğñå3.[yb®÷?s&kdÔ,átîDB$±çB •`¨!( ( ¢ ¸,ñ}nf.Móøìc&”	*ê{$ &,$ãgLŠNØ°öIZõ|do=|ı€ (ò-½&¨²1p4Ü'Yf(drsSoÔ("fÅø fODUcæMø…*ãc Nq2oe^%î÷Mlö²€=>D?÷PN@ (r©J cêB×hndq4w($bo
§ÉbCaÖ.|:#‚R¡	 …:éê"|v62vîg=e/3eTúe>Œl)
 a¢°0(ú¢$"òC#l0½w©a8@å.îkffpñí e‰u_~ 0&0ôjt6lnt¥Ñî!(ia³—n(tsÍ$%®!zÄuê,ez½lf`ŠŒ0" d¨  3$©²4n%(ïAmrGb°Wd´¥hñånîT(cU`unme)M{ Mü8N>ïE[A}Ã83@:vRm8Õ©`r@À@¨$3¢ªF¡c.05í$nf§qc&êu*1æ@ebÅP¡jz,+Z"é2<3Ÿ^¢ô,)~Ï %x×ävBà*ÎÍ ²¢70}xq üA~~äYt ("%äfe(v(i[On%]ª`Œ€¤ # èf$!oìa'uvEv$7W·gg`gp(?,ª8È¯ 0! a )  £òj"„?% è'æurÀBz?mÛ. a9r1®£!Geéh{a»qut¤áháemDL$1:EÎdeMÅ($á € ,`à¤+,#b%öó¬Ò%é/pát`7goDYs4af`c­.0JDs¯yîd{dDÃk9g`AñãÀó(Bk¿2h'„3%" …$0/idyílEï.° "µô4M¢_¥U„kw( ïu"ğXÎ*óço&q"f åre`ã "RÈ8*ğ¯7búÏTÉi¢ x"à˜%
 •(V1l¹
ÅG`es!¹F$¥]ngd2bûõ!S…u1poÿpv *c,kGõód&så¨{ñn`J50"q4$³ñn°Äj ä;¦\ålà>x3Ïknown_extends:
                self.writeline("if parent_template is not None:")
                self.indent()
            self.writeline('raise TemplateRuntimeError("extended multiple times")')

            # if we have a known extends already we don't need that code here
            # as we know that the template execution will end here.
            if self.has_known_extends:
                raise CompilerExit()
            else:
                self.outdent()

        self.writeline("parent_template = environment.get_template(", node)
        self.visit(node.template, frame)
        self.write(f", {self.name!r})")
        self.writeline("for name, parent_block in parent_template.blocks.items():")
        self.indent()
        self.writeline("context.blocks.setdefault(name, []).append(parent_block)")
        self.outdent()

        # if this extends statement was in the root level we can take
        # advantage of that information and simplify the generated code
        # in the top level from this point onwards
        if frame.rootlevel:
            self.has_known_extends = True

        # and now we have one more
        self.extends_so_far += 1

    def visit_Include(self, node: nodes.Include, frame: Frame) -> None:
        """Handles includes."""
        if node.ignore_missing:
            self.writeline("try:")
            self.indent()

        func_name = "get_or_select_template"
        if isinstance(node.template, nodes.Const):
            if isinstance(node.template.value, str):
                func_name = "get_template"
            elif isinstance(node.template.value, (tuple, list)):
                func_name = "select_template"
        elif isinstance(node.template, (nodes.Tuple, nodes.List)):
            func_name = "select_template"

        self.writeline(f"template = environment.{func_name}(", node)
        self.visit(node.template, frame)
        self.write(f", {self.name!r})")
        if node.ignore_missing:
            self.outdent()
            self.writeline("except TemplateNotFound:")
            self.indent()
            self.writeline("pass")
            self.outdent()
            self.writeline("else:")
            self.indent()

        skip_event_yield = False
        if node.with_context:
            self.writeline(
                f"{self.choose_async()}for event in template.root_render_func("
                "template.new_context(context.get_all(), True,"
                f" {self.dump_local_context(frame)})):"
            )
        elif self.environment.is_async:
            self.writeline(
                "for event in (await template._get_default_module_async())"
                "._body_stream:"
            )
        else:
            self.writeline("yield from template._get_default_module()._body_stream")
            skip_event_yield = True

        if not skip_event_yield:
            self.indent()
            self.simple_write("event", frame)
            self.outdent()

        if node.ignore_missing:
            self.outdent()

    def _import_common(
        self, node: t.Union[nodes.Import, nodes.FromImport], frame: Frame
    ) -> None:
        self.write(f"{self.choose_async('await ')}environment.get_template(")
        self.visit(node.template, frame)
        self.write(f", {self.name!r}).")

        if node.with_context:
            f_name = f"make_module{self.choose_async('_async')}"
            self.write(
                f"{f_name}(context.get_all(), True, {self.dump_local_context(frame)})"
            )
        else:
            self.write(f"_get_default_module{self.choose_async('_async')}(context)")

    def visit_Import(self, node: nodes.Import, frame: Frame) -> None:
        """Visit regular imports."""
        self.writeline(f"{frame.symbols.ref(node.target)} = ", node)
        if frame.toplevel:
            self.write(f"context.vars[{node.target!r}] = ")

        self._import_common(node, frame)

        if frame.toplevel and not node.target.startswith("_"):
            self.writeline(f"context.exported_vars.discard({node.target!r})")

    def visit_FromImport(self, node: nodes.FromImport, frame: Frame) -> None:
        """Visit named imports."""
        self.newline(node)
        self.write("included_template = ")
        self._import_common(node, frame)
        var_names = []
        discarded_names = []
        for name in node.names:
            if isinstance(name, tuple):
                name, alias = name
            else:
                alias = name
            self.writeline(
                f"{frame.symbols.ref(alias)} ="
                f" getattr(included_template, {name!r}, missing)"
            )
            self.writeline(f"if {frame.symbols.ref(alias)} is missing:")
            self.indent()
            message = (
                "the template {included_template.__name__!r}"
                f" (imported on {self.position(node)})"
                f" does not export the requested name {name!r}"
            )
            self.writeline(
                f"{frame.symbols.ref(alias)} = undefined(f{message!r}, name={name!r})"
            )
            self.outdent()
            if frame.toplevel:
                var_names.append(alias)
                if not alias.startswith("_"):
                    discarded_names.append(alias)

        if var_names:
            if len(var_names) == 1:
                name = var_names[0]
                self.writeline(f"context.vars[{name!r}] = {frame.symbols.ref(name)}")
            else:
                names_kv = ", ".join(
                    f"{name!r}: {frame.symbols.ref(name)}" for name in var_names
                )
                self.writeline(f"context.vars.update({{{names_kv}}})")
        if discarded_names:
            if len(discarded_names) == 1:
                self.writeline(f"context.exported_vars.discard({discarded_names[0]!r})")
            else:
                names_str = ", ".join(map(repr, discarded_names))
                self.writeline(
                    f"context.exported_vars.difference_update(({names_str}))"
                )

    def visit_For(self, node: nodes.For, frame: Frame) -> None:
        loop_frame = frame.inner()
        loop_frame.loop_frame = True
        test_frame = frame.inner()
        else_frame = frame.inner()

        # try to figure out if we have an extended loop.  An extended loop
        # is necessary if the loop is in recursive mode if the special loop
        # variable is accessed in the body if the body is a scoped block.
        extended_loop = (
            node.recursive
            or "loop"
            in find_undeclared(node.iter_child_nodes(only=("body",)), ("loop",))
            or any(block.scoped for block in node.find_all(nodes.Block))
        )

        loop_ref = None
        if extended_loop:
            loop_ref = loop_frame.symbols.declare_parameter("loop")

        loop_frame.symbols.analyze_node(node, for_branch="body")
        if node.else_:
            else_frame.symbols.analyze_node(node, for_branch="else")

        if node.test:
            loop_filter_func = self.temporary_identifier()
            test_frame.symbols.analyze_node(node, for_branch="test")
            self.writeline(f"{self.func(loop_filter_func)}(fiter):", node.test)
            self.indent()
            self.enter_frame(test_frame)
            self.writeline(self.choose_async("async for ", "for "))
            self.visit(node.target, loop_frame)
            self.write(" in ")
            self.write(self.choose_async("auto_aiter(fiter)", "fiter"))
            self.write(":")
            self.indent()
            self.writeline("if ", node.test)
            self.visit(node.test, test_frame)
            self.write(":")
            self.indent()
            self.writeline("yield ")
            self.visit(node.target, loop_frame)
            self.outdent(3)
            self.leave_frame(test_frame, with_python_scope=True)

        # if we don't have an recursive loop we have to find the shadowed
        # variables at that point.  Because loops can be nested but the loop
        # variable is a special one we have to enforce aliasing for it.
        if node.recursive:
            self.writeline(
                f"{self.func('loop')}(reciter, loop_render_func, depth=0):", node
            )
            self.indent()
            self.buffer(loop_frame)

            # Use the same buffer for the else frame
            else_frame.buffer = loop_frame.buffer

        # make sure the loop variable is a special one and raise a template
        # assertion error if a loop tries to write to loop
        if extended_loop:
            self.writeline(f"{loop_ref} = missing")

        for name in node.find_all(nodes.Name):
            if name.ctx == "store" and name.name == "loop":
                self.fail(
                    "Can't assign to special loop variable in for-loop target",
                    name.lineno,
                )

        if node.else_:
            iteration_indicator = self.temporary_identifier()
            self.writeline(f"{iteration_indicator} = 1")

        self.writeline(self.choose_async("async for ", "for "), node)
        self.visit(node.target, loop_frame)
        if extended_loop:
            self.write(f", {loop_ref} in {self.choose_async('Async')}LoopContext(")
        else:
            self.write(" in ")

        if node.test:
            self.write(f"{loop_filter_func}(")
        if node.recursive:
            self.write("reciter")
        else:
            if self.environment.is_async and not extended_loop:
                self.write("auto_aiter(")
            self.visit(node.iter, frame)
            if self.environment.is_async and not extended_loop:
                self.write(")")
        if node.test:
            self.write(")")

        if node.recursive:
            self.write(", undefined, loop_render_func, depth):")
        else:
            self.write(", undefined):" if extended_loop else ":")

        self.indent()
        self.enter_frame(loop_frame)

        self.writeline("_loop_vars = {}")
        self.blockvisit(node.body, loop_frame)
        if node.else_:
            self.writeline(f"{iteration_indicator} = 0")
        self.outdent()
        self.leave_frame(
            loop_frame, with_python_scope=node.recursive and not node.else_
        )

        if node.else_:
            self.writeline(f"if {iteration_indicator}:")
            self.indent()
            self.enter_frame(else_frame)
            self.blockvisit(node.else_, else_frame)
            self.leave_frame(else_frame)
            self.outdent()

        # if the node was recursive we have to return the buffer contents
        # and start the iteration code
        if node.recursive:
            self.return_buffer_contents(loop_frame)
            self.outdent()
            self.start_write(frame, node)
            self.write(f"{self.choose_async('await ')}loop(")
            if self.environment.is_async:
                self.write("auto_aiter(")
            self.visit(node.iter, frame)
            if self.environment.is_async:
                self.write(")")
            self.write(", loop)")
            self.end_write(frame)

        # at the end of the iteration, clear any assignments made in the
        # loop from the top level
        if self._assign_stack:
            self._assign_stack[-1].difference_update(loop_frame.symbols.stores)

    def visit_If(self, node: nodes.If, frame: Frame) -> None:
        if_frame = frame.soft()
        self.writeline("if ", node)
        self.visit(node.test, if_frame)
        self.write(":")
        self.indent()
        self.blockvisit(node.body, if_frame)
        self.outdent()
        for elif_ in node.elif_:
            self.writeline("elif ", elif_)
            self.visit(elif_.test, if_frame)
            self.write(":")
            self.indent()
            self.blockvisit(elif_.body, if_frame)
            self.outdent()
        if node.else_:
            self.writeline("else:")
            self.indent()
            self.blockvisit(node.else_, if_frame)
            self.outdent()

    def visit_Macro(self, node: nodes.Macro, frame: Frame) -> None:
        macro_frame, macro_ref = self.macro_body(node, frame)
        self.newline()
        if frame.toplevel:
            if not node.name.startswith("_"):
                self.write(f"context.exported_vars.add({node.name!r})")
            self.writeline(f"context.vars[{node.name!r}] = ")
        self.write(f"{frame.symbols.ref(node.name)} = ")
        self.macro_def(macro_ref, macro_frame)

    def visit_CallBlock(self, node: nodes.CallBlock, frame: Frame) -> None:
        call_frame, macro_ref = self.macro_body(node, frame)
        self.writeline("caller = ")
        self.macro_def(macro_ref, call_frame)
        self.start_write(frame, node)
        self.visit_Call(node.call, frame, forward_caller=True)
        self.end_write(frame)

    def visit_FilterBlock(self, node: nodes.FilterBlock, frame: Frame) -> None:
        filter_frame = frame.inner()
        filter_frame.symbols.analyze_node(node)
        self.enter_frame(filter_frame)
        self.buffer(filter_frame)
        self.blockvisit(node.body, filter_frame)
        self.start_write(frame, node)
        self.visit_Filter(node.filter, filter_frame)
        self.end_write(frame)
        self.leave_frame(filter_frame)

    def visit_With(self, node: nodes.With, frame: Frame) -> None:
        with_frame = frame.inner()
        with_frame.symbols.analyze_node(node)
        self.enter_frame(with_frame)
        for target, expr in zip(node.targets, node.values):
            self.newline()
            self.visit(target, with_frame)
            self.write(" = ")
            self.visit(expr, frame)
        self.blockvisit(node.body, with_frame)
        self.leave_frame(with_frame)

    def visit_ExprStmt(self, node: nodes.ExprStmt, frame: Frame) -> None:
        self.newline(node)
        self.visit(node.node, frame)

    class _FinalizeInfo(t.NamedTuple):
        const: t.Optional[t.Callable[..., str]]
        src: t.Optional[str]

    @staticmethod
    def _default_finalize(value: t.Any) -> t.Any:
        """The default finalize function if the environment isn't
        configured with one. Or, if the environment has one, this is
        called on that function's output for constants.
        """
        return str(value)

    _finalize: t.Optional[_FinalizeInfo] = None

    def _make_finalize(self) -> _FinalizeInfo:
        """Build the finalize function to be used on constants and at
        runtime. Cached so it's only created once for all output nodes.

        Returns a ``namedtuple`` with the following attributes:

        ``const``
            A function to finalize constant data at compile time.

        ``src``
            Source code to output around nodes to be evaluated at
            runtime.
        """
        if self._finalize is not None:
            return self._finalize

        finalize: t.Optional[t.Callable[..., t.Any]]
        finalize = default = self._default_finalize
        src = None

        if self.environment.finalize:
            src = "environment.finalize("
            env_finalize = self.environment.finalize
            pass_arg = {
                _PassArg.context: "context",
                _PassArg.eval_context: "context.eval_ctx",
                _PassArg.environment: "environment",
            }.get(
                _PassArg.from_obj(env_finalize)  # type: ignore
            )
            finalize = None

            if pass_arg is None:

                def finalize(value: t.Any) -> t.Any:  # noqa: F811
                    return default(env_finalize(value))

            else:
                src = f"{src}{pass_arg}, "

                if pass_arg == "environment":

                    def finalize(value: t.Any) -> t.Any:  # noqa: F811
                        return default(env_finalize(self.environment, value))

        self._finalize = self._FinalizeInfo(finalize, src)
        return self._finalize

    def _output_const_repr(self, group: t.Iterable[t.Any]) -> str:
        """Given a group of constant values converted from ``Output``
        child nodes, produce a string to write to the template module
        source.
        """
        return repr(concat(group))

    def _output_child_to_const(
        self, node: nodes.Expr, frame: Frame, finalize: _FinalizeInfo
    ) -> str:
        """Try to optimize a child of an ``Output`` node by trying to
        convert it to constant, finalized data at compile time.

        If :exc:`Impossible` is raised, the node is not constant and
        will be evaluated at runtime. Any other exception will also be
        evaluated at runtime for easier debugging.
        """
        const = node.as_const(frame.eval_ctx)

        if frame.eval_ctx.autoescape:
            const = escape(const)

        # Template data doesn't go through finalize.
        if isinstance(node, nodes.TemplateData):
            return str(const)

        return finalize.const(const)  # type: ignore

    def _output_child_pre(
        self, node: nodes.Expr, frame: Frame, finalize: _FinalizeInfo
    ) -> None:
        """Output extra source code before visiting a child of an
        ``Output`` node.
        """
        if frame.eval_ctx.volatile:
            self.write("(escape if context.eval_ctx.autoescape else str)(")
        elif fói-+®ezEh]avzá`´eUBa`cšo"(r&´3’ $ò
föæp,d<ö.å÷q¡ qj+2*¢´à#}¹so²Z@ë`dÀa$+€% rlüdJ5KÚNa.wtpºblŠJ"(x¤)‰ àma ÷iBàÎé8õ§İúé_c).tB}ow:M"d(†88 e! 3!Cd6²æg:jum-4Yod,D:uúg#;ª[d(2jµC_O}~r÷W]C&Hxºèk›üè !`,%¨ J{Áîb$N­d$*ˆod&´7 DR}8I’×iÑ?¨Îöam%Lpv)n!eMzg2OÄMKçÌI~dX.f
)¨ 0	>  N-j[: $ 4 	"I5rp¯ç FXuó (>U"ãg8óGed€ıf`o0 D)JéìI|´0)Shşr²o °sÿtÿh¡(ásfÎığUTdD^(|ida¶*#t*"`°6,* 68"b,Lˆ0h¥7gjL~uâ±öuŠ&ñb!Û(';x   9f!&[Îa	c:>sRc ê3bm.d,Ì`Nu;( ¥ q¡¤€4¨cijúroö8Pï1.»¥ ¢4ÆÖ–mdIt_Junpu²¨puì'Lj
o`O™ n?%a3A4pQgV¬¥brslgs8D2wM‰;-dº_/‚Õ2
`g"6âi7°ápÓ.!,h oxLeG=SÄÉænÃàp(6Î6`d/ú+w:WîdÄr©ogzsé & |å&HmOk~z "¥(8 ob)o1!¦$2MaõJrDmıT°0uÏcRÑÃd8(¦`20  aáqa#0q§DZ˜|Mò%ü e|vônc³<uÂc.nmş Di g8jc  `U%«ÏoPhMà ¼áåa0D !à$21b!&mm‡rgüöjeiMC^ïóm_ÿygl¡wN( hHJd`10Å( :!Ğ"5}0ºÉ5b ( `¨äğx`qåjæ.&rşôeo{Lãª)j#%t·~DTxtãy÷i'pP +ótŠO..:=	$5 á&-Qqî¨àb{ä| >i~`Ät+0ƒ
!°±# cI¦hnAììğ%30Óu(öNßLğk5_f)g"ıy8dnk '$b$‰ '$äâxS p®qÓt|ê?n­knOv{,Ís6JtJHìµu,¸ş¯d}â¾ìøø?}ß%}XSÛNd!#2`$«¬Ceva.u'5ãdncVE(¼ê¢!}y!gMñ<© timu Cl¤oã[ëÊ8bNf¤xK˜pfåå04^
9 °€e%°7Â<y–¡,o<€G(uøthïv$a ,S'u€ï` 2ômc)fÒÅõE1jò§Aª^g¤´mj=
$+%	€24¡bæQ´$k{MK áE)ÊUlõ‹m%Jgk  0a(Ku2O*8düq}n,oTg¬.naaëèä$pp>2 *(<" 5rY:À  1"€  	*  &¸(c#A~$~?~´ . ° q (h² `jm !(!,)°ãh	d"²h¹"ôéÌ	g!*ãìã%cxifâEËs`b[SzSjvig­Š~_H~`P`8($¯H$4¢Rlj` 0(< a( <é<ptjfv[ãgî&T &D!vQmMaÔ±®4aUaB¯uté``(dkM.
,".( ˜0X,8%± ˜¨‚tj&fifb~Cúg„bCN;ô™%4`é"äø¤c ¨` >ë`,h`Ï|gsø0Mä…s.g|:éc VEù(qte jcµr¸äÈÉ`Snºft,gq
  *¢ˆ&$"š,h$Xz(!\pá"ÂigÑlnKmu(÷e˜{ iZz  ! H`@%1 !-¸  0!«²--{çÿ`Nca÷h×-L> Ëïj%cCVfÍĞ­`2±=œYé£9#!'!0"1:¡,ba$ğp+a5  ìh"Ö`(|3 ") ¶ òAYqE",^dÁ~¨DÏı^ZÑYght
ohJï%$ *c 20ee #~{x#)âÕdÎêZj5}zuu]ãÉÆdS&ï]£ozsM,£)la$,"–pamu(œshâa|Ir)$ 0$ K2h* ?eURcup"ıvïü%p.N+äO2fãïh=70ÍZe,2Ú g<)ª!@0H`l pPä%(ª! ³1\h±ãnä! sÉw oërsKoÿcy$ëäCd`1.¤iqñ't/0rm b~#äUIô3ñ`qt0´# $¾°y  0`"¤-dRnô¨os©(mæ¨cv-4*%Ppdë³M¶(ra{t÷éÓíä<¥Ç*ig(*ÙsdmbwãU`;a4!@.€`@	b,)(,6 cH„I`|$cıå g´B6t|ƒ5h,:!0!b">b"4„-<"o y.dÂ#cï¤sh)0i&  È a!°%†a˜Qß*°koEdè¨°ñ¨¤'"ª©)%Ô$cofaaKì0IıéÎ8}A)cG#CzhX(0PFècáü)Ê1 !¢%Á å!0¨ p©©TO»+n qx|jGtã?kÓ4) h Cd$#" (`ãl&'B4( 3'*% åb,  4i¢olş.!p6eÆE¨["­åó|Ñ!F. 0a|>h* ha bqåu,évbælÒl¢ò&ìojmcH)
J e   !,   F -Vl¨Cëg?p¹>¨}1É@c"Œ!!1q%(Ğ0âd¤Ã!-R>0SeT)Lø~xDª8m=èL#®>M4Ccr},i°pEªD "'é$0h¥¬ :"©¨Dxs2
f @8 80 #k`  `*â%n Zv~mt!`KD	)Æ*c.s`‘}®cUvsEr=,eølem`  È*n D¨2 ); ¨³%¬§.y8`¢MU(&
$8rr † 'o3,k´eí‘iî‰ro9xM,¨0 Iq@60$Jâ#)s²Ns°Cmë`¨i4fş l`Yt@¦Dypà$(`:8&	(¡ K1P¢æğW}7o&¤iûL2td,v…gåôá¢beot¤ kgEm<DRwğì,0c&Œ($d(10B!â6ó(ª5a#i'&èÕ¶q0xß9o.ë|NâïD38fh$q	$8f€e¤”¬ íQ©.`!+c`g[±®aV.4%sh‘ nïfw"+@" ä°‚¨®$ a!!4	) :cmb~73ñ|dl}me$´hym(l!b`# 6@ã
4í 2`  )(Pf<¨¡ á.s¥{Šà…'b &¡!:( b* cÀ¯*kmè®wyíTilaÊ§$pe*0)d#.j+š%)4"  ­ã`0ˆehûnt
`&´%€!!c@¡7% 1+qF 4úi©!bYfÆö9iÃàFoìG!
0$sŠYX$e!á¸ñ ü°=da snr/kâhuAÁO!"?d}àa f9 4we‚  $t @€²$ !YÂ¢(,è²á.°d&"¤°èAöb0"`brà° ` ¹iL2noqlfm,)\±|¹:´á*(!¤0)1ª8 (:Ğ(êkF%¢|/F†ñhe|eèuiu7Q¨CüàRuoeimÅn ”(608t $+87 âgmg'ïFPtô[j,il„ZæĞ|`pt­{,#nR,á5-p­~Aah;d)Â (9$®4œ¦`!¢"0 2{el,=éw±`)8å,ø  qõu	! "¦¤1 µoè¢  1láenÏ5up%”SaHaì$Şxv×t etdlFdäz{ıv=`.	J*Âá~~1

$ *¥˜ d  iaB|ÁÎ(ô¤kNÇn`q#bib"Óù ,íeÎnveºÄ%à«0!€ À #8)ä¤  »!l|8wzb\%),";B‚°û€`  0IF nPaÍ½
"é'bÏf
Nq*ï{$©^Î¢E;’$lxB (`¡¡±0ãdînlccá0¬8%d2B °€!B<ò%©n¯w{î5a‚dë(i¢ÓHbôş%J("Oey!‚7à!$®u2i!,í
)b"(ø læ´ VÉìå,÷eeiZW;gutPt\«(uF:8i;$ Q "(ˆ n!hcllbj%0eáJÜ09 Jp.' Te¢RI3h1_KqbKef$ñelf½!f5maFN\\6vÁtS}7f<"$tùlå¨gqael1}r”Æïno:š1 1 10 üSulfNe<hOQ1hævEpah`ù!NwJ0¥! 1	 g¥zvNìvHinmmGfä)
lt`±$phnXwèÿy`¨îV<d'à#é5Ü f0clä4Ip#40¢¤°1dHæª_òıµE|4=`9&°"! l,qGln&vx3H$dı{%ì._L-*drcíe9ˆ")"+  3'nv¦+gĞ^b7WAcS4øaêK®d$f{e$i+i*1fab "I~ıÕWOsëcõDl_c*#3çyÂl¤ïmwe&bnøDÍ 	})çŒIeoD0jp%kMt0g2+e¦;¸>`¯¿g&8¨ …ˆ( bsuloÆAşrH^j*óKA¶w50åûiy~#1™ ( è(4``dmh«V$rÚuä= Æccaå}ïjdB(¡"`(¬,$`D0c T`hó ¥Q !5{R4b` l8U`{r>*SioGeIè sDTlanoA%1;”Ysact<\po~0Ïf®0 " *à )7$>Åm,°B YaÂn`2gu=aEP´;xE"qŠ>  Çø*f ò9R`&f†$B¹J(7òE%SÃ% jìg·ï2h™" e¼%!¢C‰Şkp}txD(zumo&zŒ584ğËæádvooÊÅee“#
2°(p$%1@#,é]Ğ@Ogjæé£i‘#ÉeŞÒ9dòs a¡o(y Ëilõ5m ' #* "l"c`ßfúcÅ¥&;i*W(óA!(p_d_nm$%W¿fu(.@£$%q@& u-ànuNpı"fvafe=Ì`k2c|{ume	°¨,¤4¢¢ wL&ÊqbddXèjîoãj÷gBàd]ÍÊ¥(uY ‚¡:Dn¦rojiN@a{iwÁîçDğjcMtY*blaf(^6w!Mu0
0u¨n "&İådbN5dm)*Gi{Ï`ä1	82 ,¢€á7kèç@Rh7bVˆ~{,ÍNw}Zgo|h2¯wa ç	¢f0€£Y sÁ_´l[0Y45í! m€,-Ejoux a£àsk`0e\ğjP,hYeñ|®`upçgpAag ÅlsÍ	=å,îôPd{!h (T*.G    ªF n<!e?d)dTë{*)ó@|?tmOu:*& )$"Qp0c bñï(>uos-n_Vh9uwR)*w ìo:`&x%z$c$kÂK_D{cme!K *d¬ TÔ},'2
 f(ˆòg  $ "³lfN#pieBj7g/cbV(Sfn­mø$¸@nN/£=:–Uq}É£) "¸*¨!¡`{Ô,V:1JóÖ-¬©b8Š`$@ ¢@jòd`·NôYaS;97e96p2GjAdO¯kòàäy„Š  f`ªŠÏTMä®®eÄöå†~ }%hyäya{]mça ù%"p0"ƒ0ÍIeE¹4{÷wòcc*€risEprsBp²*Pqg2uhvktpysmlvL£n.$dz¯m¤m÷.em% NsgDe¤æğ?Œm!0‰ ~M%:Œ` , $\"$kbĞë^dE<kş8 }«³tása"&Iúä€  Â°0áqC`±rqí'<¦Ql$¦ml!c÷0ªvèxe
lÿ±pWdgƒsz3nMÕHí¬aÌGfK]cXeHå¹h2·`80ã »JÀbª	 R„u1 iw sE'.Y`ÛwÈe\¯{õc%cÃ%¨(`@ À¨$1(eäb/Üaä%.?dU²ie~Zrä`ä³@ó]¾ÕÄd)-C//`A%)R*¢30„ ab¢¬0TGãMfEbnlw,òôn.~^He¯uUD,",”(@!f` ¼5*YàSvå¡Ğ3a¨¬hno	nG)]pCam6ÑÆ)êi'27ä (Yg)öH!vaüåab$A­!Wyd cxja7%`£e    >eñs%b2øMra0iv6{ uOl¥.xN¡dí Qe"§Æq{oèa(µ`ñ`,×-wg Éo –hE#To ¤2è$Ê$aá ;¡å½c9[4±0é-<±ËNÆÙM*V,Ú¢P ÖõZ'Lçtnhwhmci¡1wõ¼AtÆeYz ¤EB¡Øct.*¬$.¤  ¢3év;ı«1ëtsj-1=j¿!`2¸Z0 "6d":€aê`%¨oaâ€=ädråM+/rYH"f,{~gåbè}ncÁ 9TaC9D  ª3,²$ 0vèêaôÊf0”-	8#, ´húà a!a"l]®gdHió ;/d0=FqÂ8a`0"$ :!2€E ñ£+?»ôL~tt‘4]È½3#OAs_LKIA_EJ~Aæ‰÷w ´¤¢:ef$ ,9¡a ô©ç ½nÿ4$3måï8s V°ímÅSÏs{o]ïcal?a¬ãgä%>$  €¢Ğ$d  b 	4%*b<(¤¶2 a  -  ;díflë:i–D.O àf `0 ­D8(! a   ¬ ~n()5¬ÅEdIåcFªn£jg­)zo$D?æeÍ`#p7= qÊ!:qgmY!Xv eOÿ#pN÷`%F³.ÓX¤çua  3 *(¥hk¢!'d²#p!@i`` !H¨ 7":w½`±cï,S2S` €´`saõ(gªÿvé0u²d49"x!Emc té^xtUnScDªc{|>(æoôe4#ëuua{­n[âwfx¢s2ñeåZ L0gNU	b>¨TOâ*p0* 8 §"rcIæƒPíæwrCeJ¬j6M<"e$rcT"}yh#Yir{ W``5e{;{%f_ vI$x5õse¦õ`e³h¾iI@8‘!$ `,âpèào#>iI£BZ®otI6aîj£1àmI qı=ğr-¨´y5mF s å dÉ0U¤õIôEğ($w~'0àGkp7nŠ	‚6&•$PT¦RgøÔf(Å3a`8x.}}hw±Â}ô*¢.2á aq,D@á¢f¾zmx~
B ¥  ¬(Peæ)5:g3Agãñó9+"o,q­qf)^Šôu=JCL|
3H °1 à'gi,.&:9yw|knINF`l`$Îg!cSi~JxíîcLkwMr}­à^émÅ7{s`A	2'	Œlb a9eôFhéïd„FE8h:°.´ä¢bHsd,f®aâ}nE,Q\Å¬úåpc0 ("  (à®"s3øPcjÑlåÓa`¤åR­nTHYõNñmr²"Q´`h„!) 0:!Cbrçv Pã÷psnl±÷dÖ\dı4á 7n m~n¥Nƒd%{2ibN`^p}Ç£0 ©1ñÃ0 i!,`­CĞ   ¢ $!3G8F/kìyee,cP!Û'1!"abvEdy*w¢IpÇîaJe FÛpg{mKtìyf!>#dİ÷#cuLOq
š ¬d0àefHtyzèqPqèâtuSUb$ébl+A%¦zm%díâdssd, +4aoE:`Ró$)#)¬?ÂNïMí£  <8i ¨jô4€»#kT$isÛJæ7f
*úGhì<ávàé/rd=¨h€0 @ `f=Iûa~ÑQãücô8Rcé¬w&|ìãu(à 0@ )$ m!Inå¬öqíœ"-;T2hºU©-
hğg`¢0%ìae;   dQx00$â£'=uæ=UraTeøÈeRS ve$‰*ë!"è1@%t$6{itm$åës(1¶!Diòr)ru(fLğîh§%(°n­äoí~Ôel0–uT&ˆ21ù8 n¡m¨çbB-¤ =$ü VOïe{(d8¨0" ˆtVÚ:j"hº"%rî" x3e|6&s6[÷-,rşP:fIne¤q³ÿ#Gzrt8'R@me.Å$ñl×á|<9x0E ¨0§¨`xc…¬f i{~ïu6IdğlÅµ*@Å6› à` G  " "&"EWÿV¯3ûe}(4 ¨qj ğ¨!)l 4 .bÎI]aBoqS«ifczPe}TîGgáÍR^l®qtÌnåyaUºelœ‰[­$)EfcôevÛ-cãXnÀ¥/dK\aOp}ëvz¬!)*&¥!B-z…€m¬ãH 24%&&iStUWĞíeKsåHD+Odm=<8'`%wfRu!-A<&ş&í %:(Fpal¥í€-&d+.ía l$€#aÑuXlvbi|Ì!¸2x +0  !jm$xa= 7€a © f$\ mn˜m@MĞ%í$9o uæP]EVáœe8öotU6AöıGQ~APa(h0¡0"mà(1"`ctX#3", •#°h$ !, 63å+fnG`îPg"B: .*J!€x›™ä+dã(+AEæŠvlWyQ%ÁäoFrfrhìíƒc(p0&d3`cŒınL5Rk5Ua"®#2 ($i•xP5´°¬ì$7u%6;	iJ*Fªí7dáæ©iómOeXBxğ3sæmn-(êEdZ¢*wdF[¼Ìkqt,!ôp`­`¢F¶ùmu. ¤Ş)~oÎU2j(À¸D
HRômgöyq|$(šn1 &0a$0¡Dïr ºD8`'xõ N µ;“Eüsx-Bfodc.étEycûº/dÙ°è  ±ï)f!mvúJÅ(ˆ`  *0<a"q¤ s!lU.gyEp(»)‹¡ rt$D$À0„à2óFb¬}auid(zµgd-(¶òoi%¸l$¨@8(@dn$wr	qå(P½#z)40 tdg¾!C«{vWdiwu!;e$-(Fã&l¢lmÛÔkpu%"'b;G7"¢8am*Ğo28|zM;0`
 h'´²[adn&w2Kôÿ¨se€ˆ0…¶"`" @Jgf*éd8¾héueMi*lm35i%wãuedŒn.Å,ogdf¢í&
, ¡+$p Hhù dif_ì|
`_¤ 2ã"	 qp„$Sb c>WR`4`”b9 ¨1
!p 1"0& 0 <$3käN.äIcl<!dtfM.k]¢ìbá%%/ˆ Dğ1e à“ 1{y$Lw;mõíy3JÀB	â!è à 8`¡.!ª$wc$f­d!·ol"èdgo!t5ÅŒ*#é,u9šÀ(ãÒ° Áugvg/sjßPevgsB)u:9 1dùÃĞôñÕ`¢2û· k-ßæi.ïö*¢kâ©Bh!uêºé1KtmUf*i_EÂ{uE"9Nd0‰+	H0 nbyË3mU×É«|A¥¨ÚÁı]%_@Bæ2(¬Ä#¹:$ böIrxt(nv4«(Â=åno^jiÏêmø2O`9‚eŒ00rísIT^N$l?pz(=wï+eo]^jï*6p(â#-.ã&ä'‡sÙ7Z@61›a7i¦o&ê*jtX":*8Ã 0 öín\[IùF4%^aOqbixÏx("ud°È	@&vëkøw—à,} 'í$kqßëqjop(&cîTnà*#£3mIw)5	ò¶} OïajE_ûifıPh0-*À)Š0%¨6	SëpÖo¹$½M KEoeägp|²=â(¨$( qvo#k8nÇb½ ÿí;kbNåsí4 Amj	
«-¤rIS)|ÇJit õ&-àëYTo6h"LïD;º#; (¿ğ®tFz|q[eoznVx)0%l¡f æ	wÙlf/fã`ti#-O=%jo4dò°j}g5SYdŞba~¯cdrn/`;dEjAa¨¢4 ¼ones®hB¢áq% ê*$bá¬e>wVa,K£r8*_o}utcíaxt"°*ä e! Á O5if^Å%M¤6.pø{@rz…´}jwiæa)G6ókïşàùú®D–CIÌë}ø,vOjaå©|e"2a);,ò["o¥pY
 $&(Ñ8@v&áffaé£(e2N½Qtê&À}}×ewÿáØl
B2'"ó 1qü8ngä`JL±I-2Œ%­tlfuH_ê/-" Êá2'(< *ãm÷$ÿ¢$‡` l`²"cfmŞ6Hhk|!=,´Òğ2Şjî‰n!Úa!6%°ª)lSmÂ~nUht (â3£oİúoŞgñm«d$m")
 ,(€H1` vÎÖ%Q{(©n n.n42j%eå¹z¡%)*  # )2<)wÂüƒ*3`pi´.!{3$ dbÃ}­¨$„avq *  ãEl"·÷ph[}¸#D"éÊ!ô¡¼9¨ aWa¬w&CûYv`6„iŠ!ãæ# ZrtùY{e=~·uˆ( 8 à4æ¦t[c)0AoHlaf¥®sml&0^ÿ$å£„GëDer.e-ıøasç.&fn!©g0Gveíu½+%¾¡Koş72Î:* H27$ğ/eln¯gøc6å(³ ©`$4@h")[Ulb/fiSI~;oï£umPvØ.g^ameiŠe &"¡   DoXïğkg(nk$g>ns~j#311p  d`¤JöM(³…~éyiq(mò,ªF"aoƒ	N.0¬UÀ€$?iNtn_òI422#¤)‹Ê1 ²hdqtd†)û)xŒOpm Ìd8÷Ğlç-°hkd–: îndc;nÛpefCüìª$6øéI-RN2amf) oO&oc¶‚3ƒ   D g'l—6vp¬dD|j6!HPeCktÏÒkXjkäa+wtÍ{ NÙjh(¤aò   wwif®ô-i4d/Dcå{²u,€D`iùä¡
 D 4`{xÿm¯i`}òeirqb	0(rÜ¦`&¨ô=tÕ[d¶tdz(sdd%’®ílM€¦hş`esnW§dhåró.£kamQ(@rëïq+#1.˜Ö=}%:C±0 2À`8(©F!rzr.!§|IxlGçh`$xwA`cÙna?kì(D¢°¸£³0@ÃµÌd®ur)qu¬¢:åvi¯v%àuÔö^8k`it !  @0-êa=}u.¦ˆvbmnå&iÿÜÉZÛJ]ù.P<o¥d-td˜:1i° 0",Jwßng®¶Ic)\N=n}.~Ígn2âÂÅo:Š4á`2 ğãm÷bwb8vu.f, xo^ğuN`Vtsc^a$°J¡#B,ÀÄ+*Mfq#Gì¼'dN÷iqäeîàXé;_"a[&#J"	"ª¨0ğqæmt.Zr)8'®*+‰£¹0-Œ*M#^liiw%à¼ö6Z $ ¶dmf 7}qétQ¥uÔ;Fgì)óZ†($ëOEorfoEíz;WäRyT¥Ë|"f[àÍeFÊ˜±§W9"w`l7fàóYÀ"ª ,ğ¤b'$3mm2àá b;pÁwiHdlI&cVyÑ/mä\¦ceñèà[éÀoCqh_l>O!à¬hÆ"@iöaõchgdiwBg/n/Dõ(­rkf$n=Tluf÷~Ãóoš` 0à6³" D ákm-v.xù3OxNkä\.nIx€tr`mw©!&áh(`ô¤  #9æ	[ryºö."™S¹*°e( "!¡)"uæ(Â*RÉs-t˜~?D/&rÃD!4Rw¼9"¨g%ô¢   `òmivvrkUmˆ¢?º`!±8!"ª`ul£¯:Ş@0DàEhÀ0(Dp"o="wGÔ>e^liîMõb|îùá]¸`lC³Z` .(„ È3q$³ 02{dd¬so}ô,¬è±Ÿé`ÔévLÿ!wqYl,+
‹
`i 0"€,1 È$ [el~F^i5­j"æp*/ïnnj¼*r&?Iywi"b°±­ ¢I @	`°{etDlòks`5®ş?<t.loLe­%|wŒ)+ğ  (!8`à¢ se®gbsS/Ti8.Œ  PP( ²(2p‚¡&"!cWha$!+øtknodDHZWü*{aU¥
@ HBà$$"$ 1qe`u>e&]v-¬¡A"(/.$¤¢$8$h° 0cã(s.!l]HtyrÊ©ed*¹_aq¹~¥xº	É¤å(‚QÈ´!!q& %³F9d.43iü9Œv ¡)*"´æë °6Jòou\Wlac ÷q2Œòbi$ex#mDMc$Û<`cÑ$`f8ëmeì8Æ¹#AE#0-iNçã~7Èp0àâf-F`nïl}0yD3r0ª9÷0nLw f.M6J*3ÀhÀ0 "&0 0qbd,,òiIµ˜>$à?3tavôí ğUa+r` ´8è,bötffø*Ë÷åè2
6c®`a0   %A& ê4z9tçğ iI §Mw‚NWnk:$!"0ñ % ´b1sant97éuÂxÇşk'!p¼#.7 o£	æÂ"ª €púd jïÇ.}!uPép9 Fèv Jne# ! â`J43` $öåis.?²hNÊ"+8µ (î,jÁòc¡"$`c`lí‚vXU)& n{w~pŒtcwáà$¯*º`00@aÃä{aEXßmE.emeR" ¶äMû8îiô|s¦o1USt^#oe«/z*(#`D 4¨¤ÌJòú"tïnlúänQJyoH.Ä%vVhìgø%#odeS–·UcUy,LfqaÇ:£fêyhe¬øk—Ûmq.álÚ bnLå: #b!	(„>(Dz)T§_aX/{O~mÆC]3 à` è$ ­£ qeŞE.enrãrm#-qèdMR[äóyD#?+$$¡²‚ <d(sÁ|V¾¿¢ol‰¸*;7Uc“u §s4×ñi'aipÀ)N@±!  `®6gn Ëg!foNx|F*£4B°!r$,ğ(sed‹.Ÿ2d1¨v¿rg|b.nHnu-Ösùggdâco5¨(£¨ "© ,²	¨M(±¤öìqa?+ò}|d®Å.fjçlo/îô.`i-0ìr²>'äa ¸{*éìA%ó(ˆ   3&$D€ålU:Kd $,2u& â«¡t&¯6)ôd(N"{Óc$G*hdç0ó[Hî$a¯o!iÕ$|8fõ{T 0jx`#,;ém j.0÷î{GìC
ujl-1IúMìEw~iCóTu.3uTºş£äd>nÉHi@jÊ  ,ç$  © Z}®: iş·åDğÇ"É2ï7FlAZòzPn*mNc¬ °lM/s(5K¥'Fü(dírªl® @e*¬""ºàˆ MmèålH¦t¥0ad k¯d01­'%q2et@àFF ÿ:NıqGíQ1"iç Àpøãúnzj,xp3VzE1)¯ñ"³,BxÕõMìmë¥bÁlfå2 Edbv5JvV~øº G-ı8wì,kmÍüeÖ¡¡Î`íãc> !0$ v6d€gugk x@ zöigaãkr2&it(Äûp)m®obVF~cÍgú@""$!, ª"éz@q± ¿îB% h`"&Á­tÙ´¢áhf¨)yÏfeî]¬`€aMza ‚$¥rT(€)#€x$"€*!){Ôâ,.‘ie9nªn-(ùà‘Mm`mhŸğfeí÷dúmüä)H¹Mm+Zy¢.¯FïlecîIoaî±Éh `@‚ " q!c?y2gjzª @`ù8``0 ø9_T3oÁóFNãÎôe(ğ˜(ÇGÎptjtrŠ  â äà$&Xi÷BKrg,ee9à_Ãlníqt003+oîtE<[>lvIè\ç4z`8-$ t iˆ¤§'g¤ïg?G0'.%~V`ÒCb/Jtbu¶0nwê6ÿ:ÁÕet |Ê$d"20Euu%¹¢!t  PàiÔpq·ËÈb¥¯d0ge{ãbh MUË¿Ya0
°ô<pe*Iâ.ïFíš%H( ‚$ ©Šã`*$ 08 ¥D |k1s_h^g„Éy‘ÌGq8L-,eª  pq()(0d"` Cc$:lgriLí¨e>ãdxòYNqnci¤cà+1Sd 4ğb}n`(´ÊA±ë°4jÔHm$ïyg-rnq ¦<&»tiçb qelk`GĞd` V/{årkj/%ñd|±4q÷tĞaoaâ`!  ÀD$ ectm)´bidmerrfR`äåSö
x-á ğ¡l8ùiblA›1²<0$`,°Û{]%8vb#¾}´ jiB!1%xråja,*¡(*>¼4geü-¦Ròë4&Œ"«(‘à0hÁ¨b¬qhVsHw~bkæarOzad@=R)×Yäí*N C"`2 4d"9 scl].7r}ge+*e;&©"+H=/ÚLil©B7cK=s|
 '&8dgfò–­{ntnn`ì¤eæ*g&h¥F<FWei †ìfcsä‚a~v}ò\¢zgaeîfA2qíu)@£~GorÍ9Ÿ4*`  „,gîæ@`&‡lgZßFq`VÕrWô'wqOc/eı.ƒ,­I`Ù8£æÒÅtàP`f	>"À((4!`¥j ,8if1õ(ô/E­$µ% IMd§@Hq#@n}:wp i²e4|si%,!¡¤ga>tcp0 4%Aª42‚º(x!( *óádl´#)&œ ty :°?Pe æm$tleB|:Âg<0âìGåR
2 $"
¡(`Ğ¡Uw*ì­Öu&îmäC1|s!OÏt Ziîg>®!f ¡(  Ä"<4$â"g.d"ş}	ÿZo&c.î&¹ğgpa)eq% ®0f «`(>0imqøx6òáj,e7á5~s²@.~..cTùxaCq€`l)-à- ¡à í r´cçlncúívehx&c>à"( 1  0(0 !±,ám#iŒáb }b,å­&o!0®zF¡`mF5öçsõ$ŠJ10a (a )((,ÔP&4jÌ`á:pkN8+>nº|tårµo^Kõx8hUôoÅPnq  snOä¨pÏìbå|ß¶òáy¦/ufbdÖe™i%#%2 ( $¨¨ó;#jJ 8 ;<È  .|Í*Bãå!Iÿç6aÌ<ãôWr}™u#iÑE;3`0'¦)ã+¤f*aH€±U.f~5Pm@'ÁI3¸Ht" IZkyı(h?ÊáLgnctI$õ}«&9K!!  ' #()äAI|r*!!š"40`¨ «!@` AÍEîŠw0Í\çŠ?"!·^aep©xfâ£mm"*uFvez½,ª9Šd4 Pnivaiizf¦~4( P©æg¾¢,iv)fOUE¿,«ïlf,²ÀnTg:¤N;§'’d"äI +f¶ íJ´®Eny'¡T'æhekgbY`@E`@  $WépjbãcáæŒçi,tíò™dóäOÓïU!eã{Oth&~æòQÍ.¥Ga,Ga z‰(¬¦"$ (Ûb0$$s`ìå.nGsan€mK}w®l#äD¼h.Bbmu)H  WÍdÔñİa@Eé*ísz $% $mÃ Õùóu#khdIxtS"c%|6 (kge:¦K_%7r«Ãl?$txá2¨nV"m4*LAriáe,ä<.!Êonmz$#:! " æriyv(;ğöBaÅ¥Jómsn()&$ A0 ä?60·ãitcwGxpÃ*Ø0§`NKjm;öd 	$d¦$p-;f |ea,e8x0g/üş&1gNoZ  0,j¨`v,«0$@2àlVº~hóM4îkTan@
ãb4¬ª/pCo,á“¤‚r¹D 5¤a0àba+zixwÇ,9¢ @(  °)r=hfêvÿitig) b`C!"¤!" (9fGrnxäE$01rtúåwfmæID``hä|¿jìIŒe if)g"xZ÷úCK*4a¯0´B0$@93"( cÂ 0"°(_'j|"hğé·$ign8k/duI3"e6ãŞ´!dD$¼ë|faLsq4›zv8g-(åSa¤+# 3 (¤Û ± ¬`$‚f&a—ecq6"õõ2!¤ÿ'ie4®'
`i`2 ‚ø hX ba(è0 pe*}ò+õe8"¸").¶t >È	(ñ0=iBf0cùd¬¯mÄüåø´p¶,Erîå	*($ °­¡"b|èvìwktå* Lf *©Ê 1!°ü  £leÆf:OÖopOînG*|Dsdl`äNu%ñ)Œ4  ˆ" ¿=uvo?vI4fìâ¨*,SA öI *  00ş ïMëOåZ¸ë2x	
¡pF  !µódncn3'ÉO@"-!kŠ ¢`  ï`vOm(j­"sîC°ªB 4tdgf v}a9e_cAuX,â à $2$1emë:‚òHeo ho´Eó.Óáìâ,€zre,gúâB6am`)pJåsWìpd1coL@b* æA¿Lp>E3@K @«±-ô¡?¥Jenf
à#03(%¦»nhjm¬f$=n|iØ}Z}el,.h3´)u;vïj¢hd #( ¸7 € çME£,ö8t6*¨Qzm©A#mutİoa÷abK2   (p!è2d ælMìEjtoro.Qetr?XáGlóìK}8‰ î ²(!dä2è  RÁä¤.GAqÔF©‚Rd~?4uÿeoß,@\l¿0mjŞçrT/`")*° (  <fa%Ú x4  3¡  ÓGÌd*6Phte:jkGovaqu>eaÄìz!(P´*ddùTü./rkS9·8n~tå¼îkdu. uld¿u| q 0*&2eq|hsÏ«['sqs()eÛjc÷jl´`’{ğ2cámí/òo¡j'¡ğ¯÷-B›Óc±D<a6'à–u"b-NE
   ,!ˆ< Ugf`|ë2uvcS¢» ú(®w¬tUtavw9bÂ]ÄjORvcRØ*m yà¡cjåıMŒk/´U/|TM¡m,ñ•¿=¬¡a¦b«!ª\{tIj5 Ru{ôä“_ëDwoZRers ivärn…a665âk~f³åJd."lmf.w â9¬æK{·udcİ&¦a!¼t`Ï""u±è2q/O[@S±w;
] 0%ª£<!0óô¡q[Ke`3Vípåfp)è°ok<}K÷dbgØd*
Bì/aWß¡v`zæÉz0à` ™ 8qlh,âï9_aâ2¿ã°ïsñBfïjrkryrf¹Š!)a%Abª0A0 ÅXPğcÜ{wáòGur°¢idğÀîs7v!ãmsâX'`ìnãeCuÀbosh04(#`¤(¡:aŒÎîskëV$l%Â´*ú`O.)wÒqc#//e7{OIUy“fr©
 ¤¥*7" —GõvorIôi"='¯€(,ğ &a,²Acbgµg‚$wáöon^æn@*zó_prijB.³.!²%	ä à`sMktJ}òYpE *0¥È: „!" LW27a[-t‰y}÷®:dh$5lœŠ!?OF!`¨>Owd{jwuè×Orl¥à;lmán% s[/e;`gr8nëf`¶ v rQs7mfšs¨q|e]hsn%Î$c
oˆ&7"<"édù"=¨gO}f}lt l*”5¦ÿCnT(ª0&rkk%	
³  c´)o´e~uscæ¬fv³Cd}ú Gh`d)eÃéiÂª")h¥!f`ôqzälMiºkR1Æ`"ó,f.(oëäTºï;d%úŸÍ&j#Eknu?>æbydø@F"}e-!û Ko®Õ;
¡ xA9Bpw!¼w/7û)})..‰`*i=àxå	 ¥ #d`µ"„ı3La,V)siT¡n,f'XRr$(âûqqE }! äQLMN.1òHd}rj©r((  &åog#Sj¥oXwùmšïSoeçk.„5ü÷¦s8U‡8à'%@ _íhFhFúDu{6Vwdíp.ÍÍÚOsCefQgq·t/ğ6BĞm-p&!qaê`Ãr!e idè(>`ÎGíA:°! b¤3$¢@ql  /^2mô¥h*`ÉbRxvpàéCC/vTD5ôHnÛzqbe‘|ïask#· Eì=á°ˆşeÌì)öyIx¢!*$0!k	 úˆSaì\evOu(wç`y+Õ|:xH!vrunMK¢2  °(	%v†.{I<å¨6±7è
[ª^¢1bWâ(v-!r]Ã,vÍvoïm|4-–ìskgu¼o¨
$  *‰l cadoln¦d]Î¼j/GU—.`D`ùscêdU~ğmõÔp6r¥¨'k =e
Gbõée"4 (>wú²K}ne«&2ª( '6ñdF*zS9T4	£í xmršıeÿb;ÿ*;~ªn%&.aepˆk&b)r‡à@"t{7Í&eøTeF1*oOOvrMÜeôe "($-€rĞuçüF5©DoGI:$çëY}:LGøöd®Wm{*ctexl¤wW)`brÄmgK 2kkn
° ø1hÈª ^gÆe  "¤0¢­0§rìä.vÉiTD8F ekbYk/ëoEzü¨W||r-?.wV{gO¡}áAdd6ôé»­zbĞ=Mj{j`e+name}")

    def visit_ImportedName(self, node: nodes.ImportedName, frame: Frame) -> None:
        self.write(self.import_aliases[node.importname])

    def visit_InternalName(self, node: nodes.InternalName, frame: Frame) -> None:
        self.write(node.name)

    def visit_ContextReference(
        self, node: nodes.ContextReference, frame: Frame
    ) -> None:
        self.write("context")

    def visit_DerivedContextReference(
        self, node: nodes.DerivedContextReference, frame: Frame
    ) -> None:
        self.write(self.derive_context(frame))

    def visit_Continue(self, node: nodes.Continue, frame: Frame) -> None:
        self.writeline("continue", node)

    def visit_Break(self, node: nodes.Break, frame: Frame) -> None:
        self.writeline("break", node)

    def visit_Scope(self, node: nodes.Scope, frame: Frame) -> None:
        scope_frame = frame.inner()
        scope_frame.symbols.analyze_node(node)
        self.enter_frame(scope_frame)
        self.blockvisit(node.body, scope_frame)
        self.leave_frame(scope_frame)

    def visit_OverlayScope(self, node: nodes.OverlayScope, frame: Frame) -> None:
        ctx = self.temporary_identifier()
        self.writeline(f"{ctx} = {self.derive_context(frame)}")
        self.writeline(f"{ctx}.vars = ")
        self.visit(node.context, frame)
        self.push_context_reference(ctx)

        scope_frame = frame.inner(isolated=True)
        scope_frame.symbols.analyze_node(node)
        self.enter_frame(scope_frame)
        self.blockvisit(node.body, scope_frame)
        self.leave_frame(scope_frame)
        self.pop_context_reference()

    def visit_EvalContextModifier(
        self, node: nodes.EvalContextModifier, frame: Frame
    ) -> None:
        for keyword in node.options:
            self.writeline(f"context.eval_ctx.{keyword.key} = ")
            self.visit(keyword.value, frame)
            try:
                val = keyword.value.as_const(frame.eval_ctx)
            except nodes.Impossible:
                frame.eval_ctx.volatile = True
            else:
                setattr(frame.eval_ctx, keyword.key, val)

    def visit_ScopedEvalContextModifier(
        self, node: nodes.ScopedEvalContextModifier, frame: Frame
    ) -> None:
        old_ctx_name = self.temporary_identifier()
        saved_ctx = frame.eval_ctx.save()
        self.writeline(f"{old_ctx_name} = context.eval_ctx.save()")
        self.visit_EvalContextModifier(node, frame)
        for child in node.body:
            self.visit(child, frame)
        frame.eval_ctx.revert(saved_ctx)
        self.writeline(f"context.eval_ctx.revert({old_ctx_name})")
